import { c as create_ssr_component } from "./hooks.js";
const css = {
  code: "h2.svelte-14zln5p{text-align:left}details.svelte-14zln5p{padding:1rem;background-color:#fff0dd}li.svelte-14zln5p{padding:0.4rem}",
  map: null
};
const metadata$2 = {
  "slug": "folding-data-available",
  "title": "Folding for Data Availability; Fun for All Sizes",
  "date": "2024-03-26T00:00:00.000Z",
  "excerpt": "In this post, we will explore a new technique for generating data availability proofs, primarily leveraging cryptographic folding and the Blake3 hash function.",
  "tags": ["Cryptography", "Blockchain", "Distributed Systems"],
  "imgSrc": "/blog/warrant.webp"
};
const Folded_data_availability = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  $$result.css.add(css);
  return `<h1>Folding for Data Availability: Fun for All Sizes</h1>
<p>Data availability proofs are pivotal in distributed systems, particularly in blockchains, where they authenticate data blobs and prove data storage. While Filecoin, Ethereum light clients, and rollups all rely on these proofs, current solutions often fall short. </p>
<p>Existing solutions often employ variants of Merkle trees or variants, such as Verkle trees. Much work has been done to improve the practicallity of data-availability solutions at scale. Still, current solutions for large files often suffer from one of the following issues:</p>
<ul><li class="svelte-14zln5p">The proofs are large</li>
<li class="svelte-14zln5p">To make the proofs smaller, expensive and slow techniques are employed (I.e. using a SNARK to prove the tree path)</li>
<li class="svelte-14zln5p">To make the compression techniques less expensive, newer, algebriac hash function are used. These hash function have not stood the test of time (i.e. the Poisiden hash function)</li></ul>
<p>So, can we get around these issues? Would it be possible to use a compression technique without using an algebriac hash function? The answer seems to be yes!</p>
<p>In this post, we will explore a new technique for generating data availability proofs, primarily leveraging cryptographic folding and the Blake3 hash function.</p>
<h2 class="svelte-14zln5p">A Brief Introduction</h2>
<p>At a high level, the Blake3 hash function has an in-built Merkle-tree like mechanism to produce a hash of a large amount of data. So, to produce a data-availability proof, we simply need to generate a proof of knowledge from a random leaf to the root. For anyone familiar with Merkle trees, producing a proof requires verifying <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O( \\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span><!-- HTML_TAG_END --></span> hashes where <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><!-- HTML_TAG_END --></span> is the number of leaves in the tree. Even though the scaling is relatively efficient, there is still a significant overhead in terms of number of constraints in real-world proving systems.</p>
<p>However, the folding technique can allows us to quickly generate proofs <em>in parallel</em> for individual hash verifications in the tree and then combine them to produce the final proof. Unfortunately, at the time of writing this post, the parallelism in the folding technique is not yet implemented in the proof systems. Nontheless, folding allows for simpler circuits for proving.</p>
<h2 class="svelte-14zln5p">Data Availability Proofs at a Glance</h2>
<p>Data availability proofs are a crucial component of distributed systems. They are used to ensure that data is available to all participants in the system. In the context of blockchains, data availability proofs are used to ensure that all participants have access to the data that is being stored on the blockchain.</p>
<p>Though there are multiple ways to instantiate data availablity proofs, we will focus in on Merkle-tree based approaches. In a Merkle tree, data is stored in the leaves of the tree each inner node’s value is the hash of its children. By the magic of collision resistance and cryptography, we can expect that any party which can provide a <em>valid</em> path from a leaf to the root of the tree must be providing the <em>originally</em> hashed data. In other words, it is (cryptographically) impossible to cheat and come up with a path which yields the same root hash but is not the original data.</p>
<center><p>


<iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsMTUsWzIsMywiTF8wIl0sWzQsMywiTF8xIl0sWzYsMywiTF8yIl0sWzgsMywiTF80Il0sWzIsMiwiSChMXzApIl0sWzQsMiwiSChMXzEpIl0sWzYsMiwiSChMXzIpIl0sWzgsMiwiSChMXzMpIl0sWzAsMywiXFx0ZXh0e1xcdGV4dGJme0RhdGEgYmxvY2tzfX0iXSxbMCwyLCJcXHRleHR7XFx0ZXh0YmZ7TGF5ZXIgMn19Il0sWzAsMSwiXFx0ZXh0e1xcdGV4dGJme0xheWVyIDF9fSJdLFswLDAsIlxcdGV4dHtcXHRleHRiZntSb290fX0iXSxbMywxLCJcXHRleHR0dHtOb2RlfV8wID0gSChMXzAgXFxtaWQgXFxtaWQgTF8xKSJdLFs3LDEsIlxcdGV4dHR0e05vZGV9XzEgPSBIKExfMCBcXG1pZCBcXG1pZCBMXzEpIl0sWzUsMCwiSChcXHRleHR0dHtOb2RlfV8wIFxcbWlkIFxcbWlkIFxcdGV4dHR0e05vZGV9XzEpIl0sWzAsNF0sWzEsNV0sWzIsNl0sWzMsN10sWzQsMTJdLFs1LDEyXSxbMTIsMTRdLFs2LDEzXSxbNywxM10sWzEzLDE0XV0=&embed" width="2018" height="560" style="border-radius: 8px; border: none; zoom: 0.55; margin-left: -12rem;"></iframe>
<br>
<em>A picture of a Merkle tree where H is the hash function. For a data availability proof with 4 blocks of data, the data is stored in the leaves. <br>
	As always, <a href="https://en.wikipedia.org/wiki/Merkle_tree">Wikipedia</a> is a great resource for learning more about Merkle trees.
</em></p></center>
<p>But what now? We do not get a data-availability scheme by simply having a Merkle tree. Indeed, imagine that for Bob to prove to Alice that he has the data, he must provide any path from the leaf to the root. Bob can then simply store the path from one leaf to the root and throw out the remaining data. Bob can then provide the path to Alice and Alice will be none the wiser.</p>
<p>Instead, we need Alice to leverage randomness. Now, Alice can ask Bob to provide a path from a <em>random</em> leaf to the root. Bob cannot simply store the path from one leaf to the root and throw out the remaining data. If he does this, he will be caught out when Alice asks for a path from a different leaf to the root. Bob must store all the paths from all the leaves to the root.</p>
<h2 class="svelte-14zln5p">Folding at a Glance</h2>

<p>For simplicity, we will think about SNARKS without the ZK part (i.e. they do not preserve secrecy). In general, a SNARK can be thought of as consisting of a witness (which we will refer to as <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span><!-- HTML_TAG_END --></span>), a public input, <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span><!-- HTML_TAG_END --></span>, a public output, <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span><!-- HTML_TAG_END --></span>, and a circuit <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span><!-- HTML_TAG_END --></span>. Though often not framed in these terms, we can think of a SNARK as a proof that the circuit <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span><!-- HTML_TAG_END --></span> with inputs <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>W</mi><mo separator="true">,</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(W, I)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span><!-- HTML_TAG_END --></span> returns back the public output <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span><!-- HTML_TAG_END --></span>.</p>
<p>For our purposes, we can think of folding as doing a sort of <em>iteration</em> over a circuit. We will iterate the circuit for a number of rounds, <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span><!-- HTML_TAG_END --></span>, and at each round, we update some running proof state. For round <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span><!-- HTML_TAG_END --></span>, the update will prove that given the output from the last run, <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">O_{i - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><!-- HTML_TAG_END --></span> and witness <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">W_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><!-- HTML_TAG_END --></span>, then <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>O</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>O</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C(W_i, O_{i - 1}) = O_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><!-- HTML_TAG_END --></span>. Moreover, this proof will be “combined” with the proof from the previous round to produce a new proof for the current round.</p>
<p>In other words, we have that after round <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span><!-- HTML_TAG_END --></span>, the current proof proves that <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msub><mo separator="true">,</mo><mo>…</mo><mi>C</mi><mo stretchy="false">(</mo><msub><mi>W</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>I</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>…</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>O</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C(W_i, C(W_{i - 1}, C(W_{i - 2}, \\ldots C(W_0, I_0) \\ldots ))) = O_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mclose">)))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><!-- HTML_TAG_END --></span>.
The magic of folding is that each round’s proof can be produced in parallel and then combined to produce the final proof. (TODO: source)</p>
<center><div id="wrap">
<iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsNyxbMSwxLCJcXG1hdGhiZntDfSJdLFszLDEsIlxcbWF0aGJme0N9Il0sWzIsMiwiXFxwaV8wIFxcdGV4dHsgZm9yIH0gQyhXXzAsIElfMCkgPSBPXzAiXSxbNCwyLCJcXHBpXzEgXFx0ZXh0eyBmb3IgfSBDKFdfMSwgQyhXXzAsIElfMCkpID0gT18wIl0sWzEsMCwiV18wIl0sWzMsMCwiV18xIl0sWzAsMSwiSV8wIl0sWzAsMSwiT18wLyBJXzEiXSxbMCwyLCIiLDIseyJjdXJ2ZSI6LTF9XSxbNCwwXSxbMSwzLCIiLDIseyJjdXJ2ZSI6LTF9XSxbNSwxXSxbNiwwXV0=&embed" width="1254" height="432" style="border-radius: 8px; border: none; zoom: 0.75"></iframe>
<br>
<em>A diagram of the folding process. The circuit, C, is run sequentially for each round and the proofs are combined to produce the final proof.
</em></div></center>
<br>
<h1>Blake3</h1>
<p>The <a href="https://github.com/BLAKE3-team/BLAKE3" rel="nofollow">Blake3 hash function</a> is surprisingly suited for folding. Not only does it use a Merkle-tree like structure to hash large amounts of data, but the inner-workings of the hash function can be broken up for folding in a natural way.</p>
<p>The Blake3 hash function’s design is a variation on the Blake2 hash function. It is designed to be fast and secure and is based off of one core building block: <strong>the compression function</strong>.</p>
<details style="" class="svelte-14zln5p">
  <summary>A Note on Definitions for the Compression Function</summary>
	<br>
	Technically, the compression function in Blake3 is not the thing that I am calling a compression function here. The function that I am referring to simply runs the compression function multiple times (8 in the case of Blake3). The number of rounds is a parameter of the hash function and can be adjusted to trade off between speed and security. See the <a href="https://en.wikipedia.org/wiki/Block_cipher#Iterated_block_ciphers">Wikipedia page on block ciphers</a> for more information.
</details>
<p>The compression function can be thought of as a function which takes in a <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>512</mn></mrow><annotation encoding="application/x-tex">512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">512</span></span></span></span><!-- HTML_TAG_END --></span>-bit state, a <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>256</mn></mrow><annotation encoding="application/x-tex">256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span><!-- HTML_TAG_END --></span> bit key, and some metadata. The function then produces a <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>256</mn></mrow><annotation encoding="application/x-tex">256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span><!-- HTML_TAG_END --></span>-bit, hard to invert state.
The hash function itself is built up by chaining together multiple compression functions in various ways.</p>
<p>First, the data is split up into blocks of <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1024</mn></mrow><annotation encoding="application/x-tex">1024</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1024</span></span></span></span><!-- HTML_TAG_END --></span> bytes (or <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8192</mn></mrow><annotation encoding="application/x-tex">8192</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8192</span></span></span></span><!-- HTML_TAG_END --></span> bits). Each block is then processed <em>sequentially</em> by splitting the block into <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>256</mn></mrow><annotation encoding="application/x-tex">256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span><!-- HTML_TAG_END --></span>-bit chunks and then feeding them into the compression function. The first chunk uses a fixed bit key. Then, for all other chunks, the bit key is set to the prior chunk’s output.
The last chunk’s output is the hash of the entire block.</p>
<center>
<iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsOSxbMSwxLCJGIl0sWzMsMSwiRiJdLFs1LDEsIlxcZG90cyJdLFsxLDAsIm1fMCJdLFszLDAsIm1fMSJdLFswLDEsIlxcdGV4dHtGaXhlZCBjb25zdGFudH0iXSxbNywxLCJGIl0sWzcsMCwibV97MTV9Il0sWzksMSwiXFx0ZXh0e091dHB1dCBvZiBibG9ja30iXSxbMCwxXSxbMSwyXSxbMywwXSxbNCwxXSxbNSwwXSxbMiw2XSxbNyw2XSxbNiw4XV0=&embed" width="1617" height="304" style="border-radius: 8px; border: none; zoom: 0.7; margin-left: -5rem"></iframe>
<em>A diagram of how Blake3 hashes a block of data. Here F is the &quot;compression function&quot; and m is the 1024 byte block of data split up into 16 chunks.
</em></center>
<p>All the blocks are then hashed together in a tree-like structure to produce the final hash. The “hash function” here is the compression function.
We then get a hash algorithm which looks something like the following diagram:</p>
<center>
<iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsNyxbMCw0LCJcXHRleHR7QmxvY2t9XzAiXSxbMiwyLCJUXzAgPSBGKFxcdGV4dHtCbG9ja31fMCBcXG1pZCBcXG1pZCBcXHRleHR7QmxvY2t9XzEpIl0sWzMsNCwiXFx0ZXh0e0Jsb2NrfV8xIl0sWzUsNCwiXFx0ZXh0e0Jsb2NrfV8yIl0sWzYsMiwiVF8xID0gRihcXHRleHR7QmxvY2t9XzAgXFxtaWQgXFxtaWQgXFx0ZXh0e0Jsb2NrfV8xKSJdLFs3LDQsIlxcdGV4dHtCbG9ja31fMyJdLFs0LDAsIkgoXFx0ZXh0e2RhdGF9KSA9IEYoVF8wIFxcbWlkIFxcbWlkIFRfMSkiXSxbMCwxXSxbMiwxXSxbMyw0XSxbNSw0XSxbMSw2XSxbNCw2XV0=&embed" width="1960" height="688" style="border-radius: 8px; border: none; zoom: 0.6; margin-left:-6rem"></iframe>
<em>Here H(data) is the output of the <b>Blake3 hash function on the data</b>. Block0, Block1, etc. are the outputs of the compression function on a block of data as in the previous diagram.</em></center>
<h1>Putting it All Together</h1>
<p>Now we are cooking 🍳! We have review all the building blocks of how to do data-availability with folding. The idea is that our circuit is going to be the “compression function” of Blake3 as well as some extra logic to handle whether we are chaining together compression functions (as when hashing 1 block) or hashing multiple blocks together into a tree.</p>
<p>The <em>initial</em> public input is going to be the index of the block for which we want to prove membership. Assuming that the data block takes up the full <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1024</mn></mrow><annotation encoding="application/x-tex">1024</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1024</span></span></span></span><!-- HTML_TAG_END --></span> bytes,
we will have approximately <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mo>+</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">16 + D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span><!-- HTML_TAG_END --></span> rounds of folding where <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>=</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mtext>number of blocks</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D = \\log_2(\\text{number of blocks})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">number of blocks</span></span><span class="mclose">)</span></span></span></span><!-- HTML_TAG_END --></span>.
For the first 16 rounds, the prover shows knowledge of the block. I.e. the proof verifies that <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mtext>block</mtext><mo stretchy="false">)</mo><mo>=</mo><mtext>hash</mtext></mrow><annotation encoding="application/x-tex">H(\\text{block}) = \\text{hash}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord text"><span class="mord">block</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">hash</span></span></span></span></span><!-- HTML_TAG_END --></span> where <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span><!-- HTML_TAG_END --></span> is the hash function and <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>hash</mtext></mrow><annotation encoding="application/x-tex">\\text{hash}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">hash</span></span></span></span></span><!-- HTML_TAG_END --></span> is the hash of the block. For the remaining <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span><!-- HTML_TAG_END --></span> rounds, the prover shows knowledge of a Merkle path from the block to the root of the tree.</p>
<h4>The First <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span></span></span></span><!-- HTML_TAG_END --></span> Rounds</h4>
<p>Notice anything similiar about the two diagrams bellow? (The first is the diagram we used to explain folding and the second for the Blake3 hash function for one block)</p>
<center><div><br>
<br>
<iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsOSxbMSwxLCJGIl0sWzMsMSwiRiJdLFs1LDEsIlxcZG90cyJdLFsxLDAsIm1fMCJdLFszLDAsIm1fMSJdLFswLDEsIlxcdGV4dHtGaXhlZCBjb25zdGFudH0iXSxbNywxLCJGIl0sWzcsMCwibV97MTV9Il0sWzksMSwiXFx0ZXh0e091dHB1dCBvZiBibG9ja30iXSxbMCwxXSxbMSwyXSxbMywwXSxbNCwxXSxbNSwwXSxbMiw2XSxbNyw2XSxbNiw4XV0=&embed" width="1617" height="304" style="border-radius: 8px; border: none; zoom: 0.5; margin-left: -2rem"></iframe>
<iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsNyxbMSwxLCJcXG1hdGhiZntDfSJdLFszLDEsIlxcbWF0aGJme0N9Il0sWzIsMiwiXFxwaV8wIFxcdGV4dHsgZm9yIH0gQyhXXzAsIElfMCkgPSBPXzAiXSxbNCwyLCJcXHBpXzEgXFx0ZXh0eyBmb3IgfSBDKFdfMSwgQyhXXzAsIElfMCkpID0gT18wIl0sWzEsMCwiV18wIl0sWzMsMCwiV18xIl0sWzAsMSwiSV8wIl0sWzAsMSwiT18wLyBJXzEiXSxbMCwyLCIiLDIseyJjdXJ2ZSI6LTF9XSxbNCwwXSxbMSwzLCIiLDIseyJjdXJ2ZSI6LTF9XSxbNSwxXSxbNiwwXV0=&embed" width="1254" height="432" style="border-radius: 8px; border: none; zoom: 0.5"></iframe></div></center>
<p>Exactly! Folding fits almost perfectly with the structure of the Blake3 hash function where message chunks <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><!-- HTML_TAG_END --></span> are the witnesses <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">W_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><!-- HTML_TAG_END --></span>.</p>
<p>For each round, <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">{</mo><mn>1</mn><mo>…</mo><mn>16</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">i \\in \\{1\\dots 16\\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">16</span><span class="mclose">}</span></span></span></span><!-- HTML_TAG_END --></span>, the prover uses witness <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>chunk</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\\text{chunk}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">chunk</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><!-- HTML_TAG_END --></span> where <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext>chunk</mtext><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\\text{chunk}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord text"><span class="mord">chunk</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><!-- HTML_TAG_END --></span> is the <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span><!-- HTML_TAG_END --></span>-th chunk of the block. The public input is the index of the block, a 256-bit string as well as a few flags to keep track of where we are in the hashing. The output is the hash of chunks <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span><!-- HTML_TAG_END --></span> through <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span><!-- HTML_TAG_END --></span>. The output of each round is fed into the next round as the 26-bit string and used as a bit key. </p>

<details class="svelte-14zln5p"><summary>Extra complication with circuit</summary>
<br>
As an aside, this usage requires a little bit of extra logic within the circuit to handle the fact that the bit key is actually fixed when using the compression function for tree hashing.
</details>
<h4>The Remaining <span class="math math-inline"><!-- HTML_TAG_START --><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">D - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span><!-- HTML_TAG_END --></span> Rounds</h4>
<p>The remaining rounds are used to prove knowledge of a Merkle path from the block’s hash to the root of the tree. The circuit and input are similar to the first 16 rounds, but the flags are different. Now, the witness is the <em>sibling hash</em> to each node in the path. The 256-bit string input is now used as input to the compression function rather than as a bit key. The output of the circuit is the hash of the block and the sibling hashes.</p>
<p>Diagramatically, this can be thought of as folding over one path in the Blake3 hash function’s tree. For example, if we are trying to prove knowledge of the 1st block in a tree with 4 blocks, the folding be down over the circled path in the following diagram:</p>
<center><div class="crop" style="overflow: hidden"><img src="/blog/folded-data-avail/treescreenshot.png" alt="A diagram of the folding process for a data availability proof." style="width: min(1000px, 80%); margin: -2px 0px 0 0px;"></div></center>
<h3>The Final Proof</h3>
<p>So, now we are left with a proof that the prover knows the block and a Merkle path from the block to the root of the tree. The proof is produced by running the circuit for each round in parallel and then combining the proofs to produce the final proof. Nice!</p>
<h1>Conclusion</h1>
<p>Though we still need parrallization support for folding, we are well on our way to data-availablity proofs which are both fast to generate and small in size. With some work, authenticated data structures will become easier and easier to employ in real world systems as overheads decrease.
To keep up with progess check out the <a href="https://github.com/banyancomputer/hot-proofs-blake3-circom/tree/main" rel="nofollow">Hot Proofs Blake3</a> library.</p>`;
});
const __vite_glob_0_0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Folded_data_availability,
  metadata: metadata$2
}, Symbol.toStringTag, { value: "Module" }));
const metadata$1 = {
  "slug": "theorem-proving",
  "title": "Theorem Proving's Potential",
  "date": "2022-12-04T00:00:00.000Z",
  "excerpt": "Embedding spaces and AI, learning, and unifying programming and proving. Why I'm excited for theorem proving.",
  "tags": ["Theorem Proving"],
  "imgSrc": "/blog/lean-scratch.png"
};
const Post_theorem_prover = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<h1>Theorem Proving and Why I’m Excited</h1>
<p>I am relatively new to research and am even more noobish when it comes to theorem proving. Still, I am excited. After going through basic Lean tutorials, the <a href="https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/" rel="nofollow">Natural Number Game</a>, and most of Kevin Buzzard’s class, <a href="https://github.com/ImperialCollegeLondon/formalising-mathematics" rel="nofollow">Formalizing Mathematics</a>, I am starting to warm up to Lean but cannot quite imagine wide adoption of Lean.
Still, theorem proving has captured my imagination.</p>
<center><figure style="width: min-content"><img src="/blog/lean-scratch.png" width="400">
	<figcaption style="text-align: center;">Stable Diffusion: &quot;A pencil sketch of a programmer coding math&quot;</figcaption></figure></center>
<h2>Embedding Spaces and AI</h2>
<p>Language models are all the rage today and rightfully so. Transformer based architectures have given us the likes of GPT-3, CodeBERT, and even better LDPC code decoders. Preliminary searching shows that many researchers also attempted to train language models on the broad swath of papers on Arxiv. Though we have models which can solve math olympiad questions, none (to my knowledge) are able to handle the widely varying notation of math and computer science. A <a href="https://arxiv.org/pdf/2102.06203.pdf" rel="nofollow">recent paper</a> though shows that a language model is somewhat able to understand Lean.</p>
<p>Here is my hope: <strong>a good search engine for math and computer science</strong>. If papers attached a formalized (with Lean) statement of their main theorems and lemmas, then one could hypothetically have something akin to semantic search for theorems. Note that this would not require researchers to <em>prove</em> anything in Lean.</p>
<h2>Learning!</h2>
<p>Kevin Buzzard’s class, <a href="https://github.com/ImperialCollegeLondon/formalising-mathematics" rel="nofollow">Formalizing Mathematics</a>, is a great example of this. Though I had previous familiarity with some of the subjects being covered, I could imagine Lean being a fantastic way to learn math, especially for self-studying types of learning. Most importantly, the learner has immediate feedback: they know when there problem set responses are correct or not. For anyone who self studied math/ C.S., they know the struggle of trying to figure out when to check answer sheets to confirm uncertain answers to questions.</p>
<h2>It’s Programming but for Proofs</h2>
<p>This point is more personal. I feel right at home programming. In a very real sense, I “grew up” programming. Though I am becoming increasingly comfortable with mathematics and proofs, coding feels as easy as speaking a language --- creating proofs not so much. Don’t get me wrong, I do not write Lean with the same ease as JavaScript. Still, Lean has a comfortable familiarity.</p>
<p>I imagine that many today have a similar background to myself. Programming and coding is more accessible to 10-18 year olds than higher level maths. After all, Python has a lower barrier of entry than Algebraic Geometry.</p>
<h2>Concluding Thoughts</h2>
<p>Do I think something like Lean, Coq, or Isabelle will be massively adopted anytime soon? Not really. But, I do not see why adoption must be binary. Theorem proving is a fantastic tool which can be gradually introduced. Researchers, for example, could adopt attaching formal theorem statements and constructivist math classes could be taught with theorem provers.</p>`;
});
const __vite_glob_0_1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Post_theorem_prover,
  metadata: metadata$1
}, Symbol.toStringTag, { value: "Module" }));
const metadata = {
  "slug": "ramsey-theory-is-fun",
  "title": "Ramsey Theory is Fun: a Surprising Fact when $F(x, y) = F(y, x)$",
  "date": "2025-02-19T00:00:00.000Z",
  "excerpt": "A quick and surprising fact from Ramsey theory. For all symmetric functions $F(x, y) \\rightarrow \\mathcal{Y}$ with a reasonably sized domain, then we can find a set $S$ such that for all $x, y \\in S$, $F(x, y) \\neq \\mathcal{Y}$ of a logarithmic size (in the domain)!",
  "tags": ["Theorem Proving"],
  "imgSrc": "/blog/lean-scratch.png"
};
const Ramsey_theory_is_fun = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<h1>A Nice Lemma</h1>
<iframe src="/posts/ramsey-theory-is-fun.pdf" width="100%" height="600px" title="Ramsey Theory is Fun" style="width: 100%; height: 100%; z-index: 100; position: relative;"></iframe>`;
});
const __vite_glob_0_2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Ramsey_theory_is_fun,
  metadata
}, Symbol.toStringTag, { value: "Module" }));
export {
  __vite_glob_0_0 as _,
  __vite_glob_0_1 as a,
  __vite_glob_0_2 as b
};
